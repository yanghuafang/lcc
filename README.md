# `lcc`: Learn C Compiler

This project is a simple C compiler for learning purposes. It is based on flex, bison and LLVM.

Not like the most popular industrial C compilers, such as clang and gcc which adopt top-down recursive descendant parsing, `lcc` adopts bottom-up LALR parsing to make sure it is simple enough for teaching and self-study.

`lcc` supports the most common C grammars used in engineering practice:
- Builtin type: `char`, `short`, `int`, `long`, `float`, `double`, according `unsigned` types, `bool` and `void`.
- User defined types: struct, union and enum, according reference(`structObj.member`) and dereference(`structPtr->member`) on struct and union objects.
- Pointer and address of: `Type* objectPtr`, `objectPtr = &object`; dereference: `*objectPtr`.
- Array: `Type arrayName[INTEGER];`
- Variable list: such as `a = 1, b, c = 3`
- Variant parameters: `...`
- Function definition and call.
- `sizeof` operator.
- Explicit(`(Type)varObject`) and implicit type cast.
- Assign: `=`
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Arithemetic Assign: `+=`, `-=`, `*=`, `/=`, `%=`
- Prefix and postfix inc/dec operators: `++`, `--`
- Bitwise: `&`, `|`, `^`, `~`
- Bitwise Assign: `&=`, `|=`, `^=`
- Shift: `<<`, `>>`
- Shift Assign: `<<=`, `>>=`
- Logic: `&&`, `||`, `!`
- Comparision: `==`, `!=`, `<`, `<=`, `>`, `>=`
- Ternary expression: `condition ? trueExpr : falseExpr`
- Branch: `if`, `else`
- Branch: `switch`, `case`, `default`
- Loop: `for`, `do`, `while`
- In loop: `continue`, `break`
- In switch statement: `break`
- In function: `return`

Except the following features:
- Preprocessing: such as `#include`
- Macro definition and expansion
- Complicated initialization: such as `int a[] = {1, 2, 3}`;
- Multiple dimensional array: such as `int a[8][8];`
- `typedef`: not crucial, define by `struct`, `union` and `enum` is enough.
- `size_t`: use `unsigned long`.

`lcc` compile a translation unit(.c file) to a object file(.o), then the object file can be linked to executable by `clang` or `gcc`.  
User must specify function declarations manually for linkage.
- `printf`, instead of `#include <stdio.h>`, add a declaration before using it: `int printf(char*, ...);`
- `malloc`, add declaration: `void* malloc(unsigned long size);`
- `free`, add declaration: `void free(void* ptr);`
- `strlen`, add declaration: `unsigned long strlen(const char* s);`

## Install dependencies

`brew install flex bison llvm@14 argparse graphviz cmake`

## Build `lcc`

`git clone git@github.com:yanghuafang/lcc.git`  
`cd lcc/scripts`  
`./build-lcc.sh`  

To build by cmake manually:  
`source build-env.sh`  
`cmake -S ../ -B ../../lcc-build -DCMAKE_BUILD_TYPE=Debug`  
`cmake --build ../../lcc-build`  

To generate lexical scanner manually:  
`flex Lexer.l`

To generate syntax parser manually:
- Generate Parser.cpp and Parser.hpp  
`bison -d Parser.y`
- Generate Parser.output to check shift-reduce, reduce-reduce conflicts  
`bison -d Parser.y -v`
- Generate conflict counterexamples  
`bison -d Parser.y -Wcounterexamples &> Paser.counterexamples`

## Compile .c file

`lcc -i <input C source file> -o <object file generated> -v <AST graph file generated> -l <llvm IR file generated> -g -O<n>`

- `-i`: input C source file. It is required.
- `-o`: output object file. It is required.
- `-v`: output AST graph file(GraphViz dot file). It is optional.
- `-l`: output llvm IR code file. It is optional.
- `-g`: generate debug info within object file for debugging purpose. It is optional.
- `-O`: optimization level: `-O0`, `-O1`, `-O2`, `-O3`, `-Os`, `-Oz`. It is optional, default optimization level is `-O0`.

Generate AST graph image for debugging:  
`dot <dot file generated by '-v'> -T png -o <png file to be generated>`

## Link .o file

The object file generated can be linked by clang to run:  
`clang <object file generated> -o <executable binary file>`

## Unit tests

`cd lcc/scripts`

To compile all tests, output object file(.o), AST dot graph(.dot), AST graph image(.png), IR code(.ll):  
`./compile-tests.sh`

To link all tests:  
`./link-tests.sh`

To run all tests:  
`./run-tests.sh`

To compile one test:  
`./compile-tests.sh <C file name>`  
such as `./compile-tests.sh 0.hello_world.c`

To link one test:  
`./link-tests.sh <C file name>`
such as `./link-tests.sh 0.hello_world.c`

To run one test:  
`./run-tests.sh <C file name>`
such as `./run-tests.sh 0.hello_world.c`

## `lcc` Debugging

Use Visual Studio Code to code and debug `lcc`.  

Two LLDB debugger plugin can be used:
- `LLDB DAP`: identifier `llvm-vs-code-extensions.lldb-dap`
- `CodeLLDB`: identifier `vadimcn.vscode-lldb`

Config `lcc/.vscode/launch.json` to use one of above debugger plugins:
- `"type": "lldb-dap"` for `LLDB DAP`
- `"type": "lldb"` for `CodeLLDB`

## TODO

- Implement `lcc` `-g` option to generate object file with debug info.
- Support array initializer, such as `int arr[] = {10, 7, 8, 9, 1, 5};`
- Support multiple dimensional array.